<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>堆内存结构及简单性能调优</title>
      <link href="/2020/01/28/%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%80%E5%8D%95%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
      <url>/2020/01/28/%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%80%E5%8D%95%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<p>Java底层最重要的一部分就是jvm堆内存，它影响着Java的性能。</p><p>这篇博客主要介绍Java堆内存的分区及简单的Java调优。</p><h2 id="一、Java堆内存"><a href="#一、Java堆内存" class="headerlink" title="一、Java堆内存"></a>一、Java堆内存</h2><p>首先看这张图：</p><p><img src="https://img-blog.csdnimg.cn/20191121235622158.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>堆中的分区</li><li>Java堆内存分为两部分：<strong>年轻代、老年代</strong></li></ul><p>其中，年轻代分两个部分：<strong>Eden、Survivor</strong></p><ul><li>内存分配</li></ul><pre><code>老年代的内存占堆内总内存的2/3年轻代占1/3，在年轻代中，Eden分8/10，From和To都是1/10例：堆中总共300M空间，那么老年代有200M，年轻代有100M</code></pre><ul><li>运行时到底是什么个情况呢？</li></ul><p>当我们new一个对象之后，首先，这个对象就会被放入Eden区，直到Eden区内存被占满</p><ul><li>Eden满了之后：</li><li>Eden满了后，就会触发垃圾回收机制gc，但是呢，在这个地方是minor gc。minor gc会回收Eden区的垃圾对象（没有任何指针引用程序的对象）</li></ul><p><img src="https://img-blog.csdnimg.cn/201911220014486.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt="JVM虚拟机内部构造图"></p><ul><li>垃圾对象？</li></ul><p>可以理解为：当main函数结束时，栈帧区域会被销毁掉，然后局部变量也就被释放掉，那么指向堆中对象的指针也就被干掉了，最后，堆中的对象就是个垃圾对象。<strong>这里我们要注意一个点：查找垃圾对象的起始是从栈帧中开始的，然后查到的时一个局部变量</strong></p><ul><li>可达性分析算法？GC Root？</li></ul><p>在垃圾对象里面说了，堆中的对象是由局部变量指出的，那么我们就可以利用它来判断是不是垃圾对象，这里的局部变量就可以理解为GC Root。可达性分析算法就是以GC Root为起点，往下搜索，找到的对象就不是垃圾对象，找不到的就是垃圾对象。</p><ul><li>接着minor gc</li></ul><p>上面已经说了，minor gc只是针对Eden区的。然后，当进行一次minor gc后，Eden中的垃圾对象全部被干掉，剩下的非垃圾对象，要进入Survivor区中的From中，这时候，这些非垃圾对象的分代年龄就会加一。</p><ul><li>分代年龄？对象头？</li></ul><p>分代年龄存放在对象的对象头中，每经历一轮的垃圾回收，分代年龄就会加一<br>对象头：（<a href="https://blog.csdn.net/lkforce/article/details/81128115#1%EF%BC%8CMark%20Word" target="_blank" rel="noopener">https://blog.csdn.net/lkforce/article/details/81128115#1%EF%BC%8CMark%20Word</a>）</p><pre><code>1. Mark Word2. 指向类的指针3. 数组长度（只有数组对象才有）</code></pre><ul><li>然后Eden区再次满的时候，又会触发垃圾回收，再次将垃圾对象（包括刚刚放入from中变成新垃圾的对象）干掉，把Eden和From中非垃圾对象放入To中，并将年龄加一。</li></ul><p>当下次Eden再满的时候，又会把Eden和To中的非垃圾对象放入From中，年龄加一，以此不断循环……</p><ul><li>所以年龄有什么卵用？</li></ul><p>当进行的次数多了，直到年龄达到了15（可以改这个参数），这时候就会被移到老年代</p><ul><li>上面已经说过，老年代也有一定的大小，那么如果老年代满的时候怎么办呢？<br>这时候就会发生full gc</li></ul><p>下面我们以代码为例，查看运行时的各区情况：</p><p>利用上篇微信红包中的main函数，使它进入死循环</p><p>（对微信红包算法感兴趣的可以看：<a href="https://blog.csdn.net/qq_44357371/article/details/103115263" target="_blank" rel="noopener">https://blog.csdn.net/qq_44357371/article/details/103115263</a>）</p><pre><code>public static void main(String[] args) {        while (true) {            test.thirdMethod(5, 20);        }    }</code></pre><p><img src="https://img-blog.csdnimg.cn/20191122011034389.gif" alt=""></p><p>old就是代表老年区，我们可以看到Eden区是最快的，然后就发生垃圾回收……，和上面所述相符。</p><p><img src="https://img-blog.csdnimg.cn/20191122011342596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><p>说实话，我想看old区被塞满的情况，可惜它增长的太慢了。。。</p><ul><li>接着full gc。STW？</li></ul><p>当发生full gc时，就会产生STW（stop world，，毁掉整个世界），（哈哈哈，没这么牛逼）。这时候呢，就会暂停所有的线程，让垃圾回收机制专心的回收垃圾。这样的话，用户端会卡掉。</p><ul><li>为什么要把线程停掉呢？</li></ul><p>考虑一种情况，如果在找垃圾时，刚好已经在某个链条上面了，这时候，如果线程把这条链给干掉了，那么后面的本来应该全部是垃圾的，但是gc没有把它们给找出来，所以停掉线程。</p><h2 id="二、性能调优"><a href="#二、性能调优" class="headerlink" title="二、性能调优"></a>二、性能调优</h2><ul><li>Jvm性能调优到底调的是什么？</li></ul><p>我们上面已经知道，minor gc发生时，对性能的影响不大，但是full gc发生时，对性能的影响是巨大的。所以调优就是要减少full gc发生的次数，减少STW出现次数；还有就是在发生了Full gc时，所有的线程停掉等待垃圾回收，所以，减少垃圾回收时间。</p><p>下面举一个调优例子：</p><p><img src="https://img-blog.csdnimg.cn/20191122013401603.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><p>首先分析：</p><p>我们设置了堆的大小为3G，老年区就有2G，eden有800M，from和to各占100M</p><p>线程在运行时，每秒产生60M的对象，用后直接干掉变垃圾，这样大概每13秒就会把Eden占满，触发minor gc。</p><p>但是一个问题，在第13s产生的进程，会被直接移到survivor区，但是它的大小超过了survivor中一个区的一半，这时候触发==对象动态年龄判断机制==，直接进入老年代。</p><p>但是着60M的对象，在下一秒就又变成了垃圾。。。这样算下来，大概5、6分钟就会使老年代触发full gc，这样的效率是极其低下的。</p><p>所以呢，我们可以对这个系统进行一个调优：</p><p>把这些参数改一下，我们可以尽量让垃圾在年轻代就被干掉。</p><p><strong>总共3G，把old区设置为1G（因为没那么多要放的），这样，新生代就有了2G，这样，Eden分了1.6G，from和to分别200M</strong></p><p>这时候，每秒60M的对象过来，最后那一秒在Eden区中传入survivor中，但是根据==对象动态年龄判断机制==，60M小于from或to的一半，不会被传进老年代，变成垃圾，直接被minor gc干死，所以基本上，老年代就不可能被放满，所以就极大的改善了性能！！！</p><p>今晚收获巨大。jvm内容还多，路途且长，继续奋斗！</p><p>图片来源：诸葛老师</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM底层结构</title>
      <link href="/2020/01/28/JVM%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/"/>
      <url>/2020/01/28/JVM%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Java的优点：一次编写，处处执行，即跨平台。<br>Java如何做到跨平台呢？<br><img src="https://img-blog.csdnimg.cn/20191127121557147.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70#pic_center=400x500" alt=""></p><p>首先看这张图片，我们写的Java代码，通过Javac编译成字节码文件，然后通过Java命令进入jvm。但是在不同的平台上机器码不一样，所以jvm一个宏观上的理解就是：从软件层面屏蔽不同操作系统在底层硬件与指令上的区别。</p><h2 id="JVM虚拟机结构图"><a href="#JVM虚拟机结构图" class="headerlink" title="JVM虚拟机结构图"></a>JVM虚拟机结构图</h2><p><img src="https://img-blog.csdnimg.cn/20191127123045440.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="JVM各组成部分："><a href="#JVM各组成部分：" class="headerlink" title="JVM各组成部分："></a>JVM各组成部分：</h2><ul><li>运行时数据区（内存模型）</li><li>类转载子系统</li><li>字节码执行引擎</li></ul><h2 id="运行时数据区（内存模型"><a href="#运行时数据区（内存模型" class="headerlink" title="运行时数据区（内存模型):"></a>运行时数据区（内存模型):</h2><ul><li>堆</li><li>栈（线程栈）</li><li>本地方法栈</li><li>方法区（元空间）</li><li>程序计数器</li></ul><h4 id="栈（线程栈）"><a href="#栈（线程栈）" class="headerlink" title="栈（线程栈）"></a>栈（线程栈）</h4><p>程序在运行时会有很多个线程，每产生一个新的线程，Java的线程栈就会给线程分配一段栈内存区。<br>栈帧：Java中方法在运行时，栈会给每一个方法分配一段栈帧内存区，里面放各自方法的局部变量。栈帧内存区存放在栈中。</p><p>当方法执行完，栈帧中相应的内存区就被干掉</p><p>栈的结构：FILO，在JVM中亦然，先调用的方法，分配栈帧内存区之后压栈，后调用的方法，先被干掉。</p><p>以代码为例：</p><p><img src="https://img-blog.csdnimg.cn/20191127130535518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在代码运行时，首先线程栈会给它分配一个栈内存区，然后执行main方法，这个栈内存区给main方法分配一个栈帧内存区，并压入栈底。main方法中调用Computer时，给computer方法分配一个栈帧内存区，当Computer方法执行完成之后，将为该方法分配的栈帧从栈中干掉。最后，main方法执行完成之后，将main方法对应的栈帧干掉。（FILO）</p><p><strong>栈帧内部</strong></p><ul><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法出口</li></ul><h4 id="方法区（元空间"><a href="#方法区（元空间" class="headerlink" title="方法区（元空间)"></a>方法区（元空间)</h4><ul><li>常量</li><li>静态变量(new出来的对象放在堆里面)</li><li>类元信息</li></ul><p>堆和方法区：</p><p>堆中的对象的头会存放类的信息指针，指向方法区</p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>记录程序执行的位置。行数。</p><h4 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h4><p>每个线程独有，底层C语言与Java交互调用</p><p><em>可能有些地方说的不清楚，若有疑问，下面留言。</em> </p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过Java字节码深入理解Java执行过程及JVM底层结构</title>
      <link href="/2020/01/28/%E9%80%9A%E8%BF%87Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%8F%8AJVM%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/"/>
      <url>/2020/01/28/%E9%80%9A%E8%BF%87Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%8F%8AJVM%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>在读本文时，可以参考我的另外两篇介绍jvm的博客。</p><p><a href="https://blog.csdn.net/qq_44357371/article/details/103330641" target="_blank" rel="noopener">JVM底层结构</a></p><p><a href="https://blog.csdn.net/qq_44357371/article/details/103192906" target="_blank" rel="noopener">Java堆内存介绍及简单性能调优</a></p><h2 id="生成一个字节码文件"><a href="#生成一个字节码文件" class="headerlink" title="生成一个字节码文件"></a>生成一个字节码文件</h2><p>首先我们编写一个简单的Java文件</p><p><img src="https://img-blog.csdnimg.cn/20200121101732904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><p>在文件夹中找到这个文件，可以看到只有一个.java 文件</p><p><img src="https://img-blog.csdnimg.cn/20200121101824654.png" alt=""></p><p>在命令行使用Javac命令，生成.class文件</p><p><img src="https://img-blog.csdnimg.cn/2020012110192682.png" alt=""></p><p>使用Javap -c命令，生成字节码文件</p><p><img src="https://img-blog.csdnimg.cn/20200121102035583.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/20200121102059870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><p>看到这个乱七八糟的代码，你可能会问，，这tm是什么鬼。</p><p>下面通过<strong>JVM指令手册</strong>从Java底层对字节码进行分析</p><h2 id="字节码分析"><a href="#字节码分析" class="headerlink" title="字节码分析"></a>字节码分析</h2><h3 id="一、computer方法："><a href="#一、computer方法：" class="headerlink" title="一、computer方法："></a>一、computer方法：</h3><p><img src="https://img-blog.csdnimg.cn/20200121103143498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><h4 id="代码-int-a-1"><a href="#代码-int-a-1" class="headerlink" title="==代码 int a=1=="></a>==代码 int a=1==</h4><p>iconst_1:将int型常量①压入操作数栈</p><p>istore_2:将int类型的值存入局部变量①</p><p>结合<strong>JVM虚拟机内存结构图</strong></p><p><img src="https://img-blog.csdnimg.cn/20200121103907248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><p>首先，给常量a在操作数栈中分配一个内存空间，即<strong>iconst_1</strong>对应<strong>int a</strong></p><p>然后，把常量a的值变成1，并存进局部变量表，即<strong>istore_2</strong>对应<strong>a=1</strong></p><h4 id="代码-int-b-2"><a href="#代码-int-b-2" class="headerlink" title="代码 int b=2"></a>代码 int b=2</h4><p>iconst_2:将int型常量②压入操作数栈</p><p>istore_2:将int类型的值存入局部变量②</p><p>同理，很容易理解</p><h4 id="代码-return-a-b"><a href="#代码-return-a-b" class="headerlink" title="代码 return a+b"></a>代码 return a+b</h4><p>iload_1：从局部变量①中转载int类型值  即<strong>a的值1</strong></p><p>iload_2：从局部变量②中装载int类型值  即<strong>b的值2</strong></p><p>即把变量a的值1给装载出来，放在操作数栈</p><p>把变量b的值2给装载出来，放在操作数栈</p><p><img src="https://img-blog.csdnimg.cn/20200121105426146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><p>iadd:执行int类型的加法</p><p>即从操作数栈中依次弹出栈顶元素相加，最终生成的结果压回操作数栈    <strong>a+b</strong></p><p>最后 ireturn:从当前方法返回int</p><p>从操作数栈中弹出3</p><p>即对应 <strong>return 3</strong></p><h3 id="二、main方法"><a href="#二、main方法" class="headerlink" title="二、main方法"></a>二、main方法</h3><p><img src="https://img-blog.csdnimg.cn/20200121110948756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><h4 id="代码-Test-test-new-Test"><a href="#代码-Test-test-new-Test" class="headerlink" title="代码 Test test = new Test()"></a>代码 Test test = new Test()</h4><p> new：创建一个对象</p><p> 我们对比上面的 int a 可以知道，new出来的test 也是一个局部变量，它被存放在main方法对应的栈帧内存区的局部变量表中，<br> 但在jvm底层，对象创建之后放在堆中，</p><p> 这样我们就可以发现栈和堆之间的一个联系。</p><p> <strong>那么，这两个东西真的就是一样的嘛？</strong></p><p> 其实，局部变量表中存放的是堆中对象对应的内存地址，即可以理解为它存放一个指向堆中对象的指针。</p><p> <img src="https://img-blog.csdnimg.cn/20200121112345695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><p> 到这里，我们就可以通过字节码在jvm底层结构理解整个Java代码的执行过程。</p><p> 最后还有一个问题</p><p><img src="https://img-blog.csdnimg.cn/20200121112738874.png" alt="">)<img src="https://img-blog.csdnimg.cn/20200121112648124.png" alt="在这里插入图片描述"></p><p>在执行main方法时，会跳出去转到computer方法中，在执行完computer方法后，它会再回到main方法中，但是，它回到哪了呢？</p><p>方法出口就记录着返回的位置。</p><p>同样，程序计数器？</p><p><img src="https://img-blog.csdnimg.cn/20200121113147728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><p>它记录着程序执行的位置，即行数</p><p>设想，在Java代码执行时，经常会有多个线程。学过操作系统的就知道，cpu在运行时，经常会发生线程被抢占，被执行的线程挂起。那么，这个线程被挂起之后，它重新运行时，从哪开始呢？</p><p>程序计数器就解决了这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法调用（解析、动态分派、静态分派）</title>
      <link href="/2020/01/28/JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%88%E8%A7%A3%E6%9E%90%E3%80%81%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE%E3%80%81%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%EF%BC%89/"/>
      <url>/2020/01/28/JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%88%E8%A7%A3%E6%9E%90%E3%80%81%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE%E3%80%81%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>参考文章：</p><p><a href="https://blog.csdn.net/wangdongli_1993/article/details/81428848" target="_blank" rel="noopener">JVM（十四）方法调用</a></p><p><a href="https://blog.csdn.net/fan2012huan/article/details/51004615" target="_blank" rel="noopener" title="java方法调用之单分派与多分派（二）">java方法调用之单分派与多分派（二）</a></p><p>方法调用阶段就是确定被调用方法的版本，即调用哪一个方法。</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>我们已经知道，class文件中需要调用的方法都是一个符号引用，而在方法调用中的解析阶段，就是要把一部分符号引用转化为直接引用。</p><p>能在解析阶段将方法的符号引用转化成直接引用的的方法，必须在方法运行前就确定一个可调用的版本，并且这个版本在运行阶段是不可改变的。</p><p>“编译期可知，运行期不可变”，符合这个规则的方法有静态方法和私有方法两大类。前者与所属的类直接关联，后者在外部不可以被访问。这两种方法都适合在解析调用，也就是把这些方法的符号引用转化成直接引用。</p><p>与之对应5条调用方法的字节码指令：</p><ul><li><strong>invokestatic:调用静态方法</strong></li><li><strong>invokespecial：调用实例构造器<init>方法，私有方法和父类方法</strong></li><li><strong>invokevirtual：调用所有虚方法</strong></li><li><strong>invokeinterface：调用接口方法，运行时确定一个实现此接口的对象</strong></li><li><strong>invokedynamic:先在运行时动态解析出调用点限定符所引用的的方法，然后再执行此方法</strong></li></ul><p>只有用invokestatic和invokespecial指令调用的方法（还有final修饰的方法），都可以在解析阶段确定调用版本，这些方法叫做非虚方法。</p><p>剩下三个字节码指令调用的方法叫做虚方法（invokevirtual指令调用的final修饰的方法除外）</p><p>解析调用是一个静态过程，编译期间就可以确定，解析阶段将符号引用转化为直接引用。</p><p><img src="https://img-blog.csdnimg.cn/20200127104051600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><p>将代码转换为字节码文件：</p><p><img src="https://img-blog.csdnimg.cn/20200127104142282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><p>可以看到，确实是通过invokestatic命令调用sayhello方法。</p><h1 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h1><h2 id="1-静态分派—（重载）"><a href="#1-静态分派—（重载）" class="headerlink" title="1. 静态分派—（重载）"></a>1. 静态分派—（重载）</h2><p>先看一段简单的代码：</p><p><img src="https://img-blog.csdnimg.cn/20200127105004799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><p>输出结果是什么？</p><p>我们先来分析一下：</p><p>首先引入两个概念：我们把代码中的Human成为变量的<strong>静态类型</strong>，把Man、Woman称为变量的<strong>实际类型</strong>。<br>静态类型和动态类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，<strong>编译器在编译程序的时候不知道一个对象的实际类型是什么</strong>。</p><p>现在再看代码，对于sd.sayHello(man);直观上看，它似乎传入的是Man类型的参数man，所以应该打印的是man的方法“man is saying hello”，</p><p>但是要注意，man 的静态类型仍然是Human，实际类型才是man，所以，在编译阶段，Javac选择了sayHello(Human)作为调用目标。</p><p>即最终输出：</p><p><img src="https://img-blog.csdnimg.cn/20200127110639837.png" alt=""></p><p>通过这个实例，我们可以看到，这里是通过静态类型来定位执行方法的版本，这样的分派动作称为<strong>静态分派</strong><br>静态分派于重载有很深的关系</p><h2 id="2-动态分派—（重写）"><a href="#2-动态分派—（重写）" class="headerlink" title="2. 动态分派—（重写）"></a>2. 动态分派—（重写）</h2><p>先看代码：</p><p><img src="https://img-blog.csdnimg.cn/20200127112750917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><p>生成字节码文件：</p><p><img src="https://img-blog.csdnimg.cn/20200127113823727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><p>注意代码中的：</p><p><img src="https://img-blog.csdnimg.cn/20200127114045571.png" alt=""></p><p>对应字节码中的：</p><p><img src="https://img-blog.csdnimg.cn/20200127114132633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><p>invokevirtual指令的运行时解析过程大致分为：</p><p>（1）找到操作数栈栈顶的第一个元素所指向的对象的实际类型。记作C。</p><p>（2）如果在类型C中找到与常量描述符和简单名称相符的方法，就进行访问权限校验，通过则返回方法的直接引用，没有通过则抛出java.lang.IllegalAccessError异常</p><p>（3）如果在类型中没有找到对应的方法，则按照继承关系从下往上对C的父类依此查找方法</p><p>（4）若始终没有找到合适方法，抛出java.lang.AbstractMethodError异常。</p><p>invokevirtual指令执行的时候先确定方法调用的对象的实际类型，所以会把两次方法调用的符号引用解析到不同的直接引用上，这个过程叫做<strong>动态分派</strong>，是方法重写的本质。</p><p>代码结果为：</p><p><img src="https://img-blog.csdnimg.cn/20200127124154544.png" alt=""></p><h2 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h2><p>先看一段代码：</p><pre><code>public class Dispatcher {    static class QQ {}    static class _360 {}    public static class Father {        public void hardChoice(QQ arg) {            System.out.println(&quot;father choose QQ&quot;);        }        public void hardChoice(_360 arg) {            System.out.println(&quot;father choose _360&quot;);        }    }    public static class Son extends Father {        @Override        public void hardChoice(QQ arg) {            System.out.println(&quot;son choose QQ&quot;);        }        public void hardChoice(_360 arg) {            System.out.println(&quot;son choose 360&quot;);        }    }    public static void main(String[] args) {        Father father = new Father();        Father son = new Son();        father.hardChoice(new _360());        son.hardChoice(new QQ());    }}</code></pre><p>运行结果是什么？</p><p><img src="https://img-blog.csdnimg.cn/20200129100434458.png" alt=""></p><p>它的字节码文件：</p><p><img src="https://img-blog.csdnimg.cn/20200129103435680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><p>我们分别从<strong>静态分派</strong>和<strong>动态分派</strong>的角度来分析</p><h3 id="1-静态分派"><a href="#1-静态分派" class="headerlink" title="1. 静态分派"></a>1. 静态分派</h3><p>看字节码的</p><pre><code>24: invokevirtual #8                  // Method 单分派多分派/Dispatcher$Father.hardChoice:(L单分派多分派/Dispatcher$_360;)V35: invokevirtual #11                 // Method 单分派多分派/Dispatcher$Father.hardChoice:(L单分派多分派/Dispatcher$QQ;)V</code></pre><p>对应的是代码的：</p><pre><code>father.hardChoice(new _360());son.hardChoice(new QQ());</code></pre><p>可以看到，invokevirtual相同，调用的都是<strong>$Father.hardChoice</strong>方法，只是他们的参数不同。</p><p>这说明他们的静态类型相同，都是Father。在选择目标方法时，根据两个<strong>宗量</strong>，是多分派的，即<strong>静态分派属于多分派类型</strong>。</p><blockquote><p>宗量：方法的接收者和方法的参数统称为方法的宗量。</p></blockquote><blockquote><p>单分派：根据一个宗量对目标方法进行选择</p></blockquote><blockquote><p>多分派：多于一个宗量对目标方法进行选择</p></blockquote><h3 id="2-动态分派"><a href="#2-动态分派" class="headerlink" title="2. 动态分派"></a>2. 动态分派</h3><p>当在执行</p><pre><code>father.hardChoice(new _360());son.hardChoice(new QQ());</code></pre><p>发现son的实际类型是Son，所以转去调用Son的方法。在father中也执行了此过程，只不过，father的实际类型仍然是father。</p><p>目标选择时只依据了一个宗量，是单分派的。因此，<strong>动态分派属于单分派类型</strong>。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>静态分派关注了两个宗量，即<strong>静态类型和参数</strong>，（参数对比重载）</p><p>而动态分派关注<strong>实际类型</strong>，（对比重写）</p><p><strong>java语言是一个静态多分派，动态单分派的语言</strong></p><h2 id="动态分派的实现"><a href="#动态分派的实现" class="headerlink" title="动态分派的实现"></a>动态分派的实现</h2><p>动态分派类似重写，动态分派是非常频繁的动作，运行时需要在元数据中搜索合适的目标方法，最常用的“稳定优化”手段就是建立一个虚方法表，存放各个方法实际入口地址。</p><p>子类重写了方法，就会指向子类的方法地址。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 字节码执行引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字节码执行引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行时栈帧结构</title>
      <link href="/2020/01/28/JVJVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E1%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84/"/>
      <url>/2020/01/28/JVJVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E1%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>栈帧中包括：局部变量表、操作数栈、动态链接、方法出口。</p><p><img src="https://img-blog.csdnimg.cn/20200126175647510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h2><p>在<a href="https://blog.csdn.net/qq_44357371/article/details/104072447" target="_blank" rel="noopener">类加载的过程</a>中已介绍过类加载过程中的解析阶段，是将符号引用转换为直接引用，但是是静态的。<br>在与运行期间转化为直接引用就是动态连接。</p><p>其他部分可参考阅读</p><p><a href="https://blog.csdn.net/qq_44357371/article/details/103330641" target="_blank" rel="noopener">JVM底层结构</a></p><p><a href="https://blog.csdn.net/qq_44357371/article/details/104059180" target="_blank" rel="noopener">通过Java字节码深入理解Java执行过程及JVM底层结构</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 字节码执行引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字节码执行引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器</title>
      <link href="/2020/01/28/JVJVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B63%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/2020/01/28/JVJVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B63%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>类加载器：实现 “ 通过类的全限定名来获取描述此类的二进制字节流 ” 的模块<br><img src="https://img-blog.csdnimg.cn/20200126141937329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p></blockquote><h2 id="类加载器种类："><a href="#类加载器种类：" class="headerlink" title="类加载器种类："></a>类加载器种类：</h2><ul><li><strong>启动类加载器</strong>：负责加载支撑JVM运行的位于jre/lib目录下的核心类库（例如：String、Object类），在虚拟机启动时就会加载完，以支撑虚拟机的运行。对于hotspot，这个类加载器使用C++实现。</li><li><strong>扩展类加载器</strong>：负责加载支撑JVM运行的位于jre/lib/ext中的JAR包。由Java语言实现，父类加载器为null。</li><li><strong>应用程序类加载器</strong>：负责加载用户路径ClassPath下的类库。由Java语言实现，父类加载器为ExtClassLoader。</li></ul><p>类加载器加载Class大致要经过如下8个步骤：</p><ol><li>检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。</li><li>如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。</li><li>请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。</li><li>请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。</li><li>当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。</li><li>从文件中载入Class，成功后跳至第8步。</li><li>抛出ClassNotFountException异常。</li><li>返回对应的java.lang.Class对象。</li></ol><h2 id="类加载机制："><a href="#类加载机制：" class="headerlink" title="类加载机制："></a>类加载机制：</h2><ul><li>全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</li><li>双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。</li><li>缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。</li></ul><p><strong>双亲委派机制</strong></p><p><img src="https://img-blog.csdnimg.cn/2020012615383646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70#pic_center=300x300" alt=""></p><p>双亲委派机制要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，但这里的父子关系是组合关系</p><blockquote><p>组合关系，是关联关系的一种，是比聚合关系强的关系。它要求普通的聚合关系中代表整体的对象负责代表部分对象的生命周期，组合关系是不能共享的。代表整体的对象需要负责保持部分对象和存活，在一些情况下将负责代表部分的对象湮灭掉。代表整体的对象可以将代表部分的对象传递给另一个对象，由后者负责此对象的生命周期。换言之，代表部分的对象在每一个时刻只能与一个对象发生组合关系，由后者排他地负责生命周期。部分和整体的生命周期一样。</p></blockquote><p>对于我们写出来的.class文件，即对应<strong>应用程序加载器</strong>，它在加载时，首先会向上委托，委托给他的父亲，即<strong>扩展类加载器</strong>，扩展类加载器继续向上委托，给<strong>启动类加载器</strong>，而启动类加载器没有父类，则在启动类加载器查找是否有这个类，有则加载，无则打回；然后在扩展类加载器中找，有则加载，无则打回；最后在应用程序类加载器中加载。</p><p>  <strong>双亲委派机制的优势</strong>：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</p><p>我们以一个简单的代码为例：</p><p><img src="https://img-blog.csdnimg.cn/20200126151932356.png" alt=""></p><p>我们自己定义一个String类，注意==在java.lang包中也有一个系统自带的String类==，而我们定义的这个类，包名也叫做java.lang，运行结果怎么样呢 ？</p><p><img src="https://img-blog.csdnimg.cn/20200126152208405.png" alt=""></p><p>为啥会找不到main方法？<br>这里就要从双亲委托机制进行解释：我们定义的这个类在加载时首先是对应应用程序类加载器，它要向上委托，直到启动类加载器。</p><p>上面已经说过，启动类加载器加载的是位于jre/lib目录下的核心类库，其中就有String类，这个String类就在java.lang 中，所以我们自定义的这个String类在最上层的启动类加载器中被核心类库里的String类替换掉了！</p><p>参考文章：<a href="https://blog.csdn.net/m0_38075425/article/details/81627349" target="_blank" rel="noopener">https://blog.csdn.net/m0_38075425/article/details/81627349</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 类加载机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类加载机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载的过程</title>
      <link href="/2020/01/28/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B62%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/01/28/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B62%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200122204152483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ul><li>将类的.class文件中的二进制数据读入到内存中</li><li>将其放在运行时数据区的方法区内</li><li>然后再内存中创建一个java.lang.Class对象用来封装类在方法区内的数据结构</li></ul><p>简单地说，加载：在硬盘上查找并通过IO读入字节码文件</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>目的：确保Class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<br>主要分为四个检验部分：</p><ol><li>文件格式验证：检验是否为class文件</li><li>元数据验证：验证是否符合Java语言规范</li><li>字节码验证：检验程序是否合法，符合逻辑</li><li>符号引用验证：保证该引用能够被访问到</li></ol><p>要注意，验证阶段是非常重要的，但并不是一定必要的，对于反复使用和验证过的代码，可以通过使用-Xverify：none来关闭大部分类验证，来缩短验证时间。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为类变量分配内存，设置类变量初始值</p><p>要注意的是：</p><ul><li>内存分配仅包括类变量（static），不包括实例变量，实例变量会在对象实例化时随对象分配在Java堆中</li><li>初始值在通常情况下是0，并不是程序里的那个值。真正的赋值是在初始化时完成的。<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2>将<strong>符号引用</strong>替换为<strong>直接引用</strong>，该阶段会把一些<strong>静态方法</strong>替换为指向数据所存内存的指针或句柄等（<strong>直接引用</strong>），这是所谓的<strong>静态链接</strong>的过程（程序加载期间完成），<strong>动态链接</strong>时在程序运行期间完成的<strong>符号引用</strong>替换为<strong>直接引用</strong>。</li></ul><p><strong>符号引用</strong>：用符号来表示目标，符号可以是任意的字面量，要求无歧义</p><p>我们以字节码文档为例：</p><p>将一个简单的代码用javap命令生成字节码文件，内容如下</p><pre><code>package Test;public class Test {    public int computer(){        int a=1;        int b=2;        return a+b;    }    public static void main(String[] args) {        Test test = new Test();        int c = test.computer();        System.out.println(c);    }}</code></pre><p>```</p><pre><code>Classfile /C:/Users/董润泽/workspace/Java虚拟机/src/Test/Test.class  Last modified 2020-1-21; size 490 bytes  MD5 checksum 1015aa0bd5fd4af85cc23a21ef42a1af  Compiled from &quot;Test.java&quot;public class Test.Test  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #7.#18         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Class              #19            // Test/Test   #3 = Methodref          #2.#18         // Test/Test.&quot;&lt;init&gt;&quot;:()V   #4 = Methodref          #2.#20         // Test/Test.computer:()I   #5 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;   #6 = Methodref          #23.#24        // java/io/PrintStream.println:(I)V   #7 = Class              #25            // java/lang/Object   #8 = Utf8               &lt;init&gt;   #9 = Utf8               ()V  #10 = Utf8               Code  #11 = Utf8               LineNumberTable  #12 = Utf8               computer  #13 = Utf8               ()I  #14 = Utf8               main  #15 = Utf8               ([Ljava/lang/String;)V  #16 = Utf8               SourceFile  #17 = Utf8               Test.java  #18 = NameAndType        #8:#9          // &quot;&lt;init&gt;&quot;:()V  #19 = Utf8               Test/Test  #20 = NameAndType        #12:#13        // computer:()I  #21 = Class              #26            // java/lang/System  #22 = NameAndType        #27:#28        // out:Ljava/io/PrintStream;  #23 = Class              #29            // java/io/PrintStream  #24 = NameAndType        #30:#31        // println:(I)V  #25 = Utf8               java/lang/Object  #26 = Utf8               java/lang/System  #27 = Utf8               out  #28 = Utf8               Ljava/io/PrintStream;  #29 = Utf8               java/io/PrintStream  #30 = Utf8               println  #31 = Utf8               (I)V{  public Test.Test();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 3: 0  public int computer();    descriptor: ()I    flags: ACC_PUBLIC    Code:      stack=2, locals=3, args_size=1         0: iconst_1         1: istore_1         2: iconst_2         3: istore_2         4: iload_1         5: iload_2         6: iadd         7: ireturn      LineNumberTable:        line 5: 0        line 6: 2        line 7: 4  public static void main(java.lang.String[]);    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=2, locals=3, args_size=1         0: new           #2                  // class Test/Test         3: dup         4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V         7: astore_1         8: aload_1         9: invokevirtual #4                  // Method computer:()I        12: istore_2        13: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;        16: iload_2        17: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V        20: return      LineNumberTable:        line 10: 0        line 11: 8        line 12: 13        line 13: 20}SourceFile: &quot;Test.java&quot;</code></pre><p>可以看到，上面有一些“#数字”：</p><p><img src="https://img-blog.csdnimg.cn/20200122220623936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzU3Mzcx,size_16,color_FFFFFF,t_70" alt=""></p><p>这其实就是生成的符号，对于后面的解释，例如“#7：#8”即指“#1”这个符号引用了“#7”和“#8”的内容</p><p>这即为符号引用</p><p><strong>直接引用</strong>：引用的是目标的一个地址</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>对类的静态变量初始化为指定的值，执行静态代码块</p><p>同准备阶段的赋初始值不同！</p><p>在博客 <a href="https://drunze.github.io/2020/01/28/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B61%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA/" target="_blank" rel="noopener">类加载的时机</a>已介绍，可参考理解。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 类加载机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类加载机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载的时机</title>
      <link href="/2020/01/28/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B61%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA/"/>
      <url>/2020/01/28/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B61%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>虚拟机如何加载Class文件？<br>Class文件里的信息进入虚拟机会发生怎样的变化？</p><blockquote><p>虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是类加载机制</p></blockquote><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类从被加载到内存到卸载出内存，生命周期：<br><strong>加载、连接</strong>（验证、准备、解析）<strong>、初始化、使用、卸载</strong></p><p><strong>初始化：</strong></p><ol><li>遇到new、getstatic、putstatic或invokestatic,若类未初始化，则触发初始化</li><li>使用java.lang.reflect对类进行反射调用</li><li>父类没有进行过初始化，先初始化父类</li><li>虚拟机启动时，先初始化要执行的主类</li><li>若java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic的句柄，若此方法句柄对应的类没有进行过初始化，则要先初始化。</li></ol><p>下面以代码来演示</p><pre><code>//父类superClass    public class SuperClass {        static {            System.out.println(&quot;SuperClass init!&quot;);        }    public static int sup = 1111111;    }//子类subClass    public class subClass extends SuperClass{        static {            System.out.println(&quot;SubClass init!&quot;);        }        public static int sub = 2222222;    }</code></pre><p><img src="https://img-blog.csdnimg.cn/20200122152246616.png" alt=""></p><p>guess结果是啥？</p><p>分析，参考上面规则的第三条： <strong>3. 父类没有进行过初始化，先初始化父类</strong></p><p>首先是subClass.sub:要调用子类中的静态变量sub，那就要初始化子类，但是在子类初始化之前，还要去先初始化父类，最后才打印sub的值</p><p>在运行第二句时，两个类已经经过初始化，那么直接打印值即可。</p><p><img src="https://img-blog.csdnimg.cn/20200122152617903.png" alt=""></p><pre><code>public static void main(String[] args) {    SuperClass[] sca = new SuperClass[10];}</code></pre><p>这样，并没有输出superClass init！<br>它代表了元素类型为superClass的一维数组，它是继承于java.lang.Object的子类</p><pre><code>public class ConstClass {    static{        System.out.println(&quot;ConstClass init!&quot;);    }        public static final String Hello = &quot;Hello!&quot;;}public class NotInitialization {    public static void main(String[] args) {        System.out.println(ConstClass.Hello);    }}</code></pre><p>输出什么？</p><p><img src="https://img-blog.csdnimg.cn/20200122185027629.png" alt=""></p><p>Hello！!</p><p>为啥没有执行static里面的语句呢？？？</p><p>这里用了final，即Hello是常量，它被存放在常量池中，和ConstClass这个类没有了联系，主函数在执行时，不需要对ConstClass类进行初始化，所以最终只打印“ Hello！”</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 类加载机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类加载机制 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
